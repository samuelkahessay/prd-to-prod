#
# PR Review Submit — Watches for pr-review-agent verdict comments and submits
# the formal GitHub review as github-actions[bot].
#
# This is a standard GitHub Actions workflow (not an agentic .md workflow)
# so that it submits the formal review with GITHUB_TOKEN
# (github-actions[bot] identity). This ensures a different identity from the
# GitHub App that creates PRs, avoiding GitHub's self-approval restriction.
# For approved pipeline PRs, the auto-merge command intentionally switches to
# GH_AW_GITHUB_TOKEN so the resulting push to main can trigger downstream
# workflows such as Deploy to Azure.
#
# Flow:
#   1. pr-review-agent posts a verdict comment starting with [PIPELINE-VERDICT]
#   2. This workflow fires on issue_comment:created, detects the marker
#   3. Parses APPROVE or REQUEST_CHANGES from the comment body
#   4. Submits the formal GitHub review as github-actions[bot]
#   5. On APPROVE: marks draft PRs ready, enables auto-merge for [Pipeline] PRs
#   6. Dispatches repo-assist for next cycle (APPROVE) or posts /repo-assist (REQUEST_CHANGES)
#
# Break-glass: workflow_dispatch allows manual review submission when the
# comment-based flow is blocked (e.g., action_required on first-time contributor).
#

name: "PR Review Submit"

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to submit review for"
        required: true
        type: number
      verdict:
        description: "Review verdict"
        required: true
        type: choice
        options:
          - APPROVE
          - REQUEST_CHANGES
      summary:
        description: "Review summary"
        required: false
        type: string
        default: "Manual break-glass review submission."

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write
  statuses: write

# ---------------------------------------------------------------------------
# Job 1: issue_comment trigger — automated path
# ---------------------------------------------------------------------------
jobs:
  submit-review-comment:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request != null &&
      startsWith(github.event.comment.body, '[PIPELINE-VERDICT]') &&
      contains(github.event.comment.body, 'gh-aw-agentic-workflow: Pipeline Review Agent') &&
      github.event.comment.user.login == github.repository_owner

    concurrency:
      group: "pr-review-submit-${{ github.event.issue.number }}"
      cancel-in-progress: false

    env:
      PIPELINE_HEALING_ENABLED: ${{ vars.PIPELINE_HEALING_ENABLED }}

    steps:
      - name: Checkout workflow helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: scripts/healing-control.sh
          sparse-checkout-cone-mode: false

      - name: Check healing pause switch
        id: healing
        run: |
          if scripts/healing-control.sh is-enabled; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "Autonomous healing is paused via PIPELINE_HEALING_ENABLED."
          fi

      - name: Check idempotency (skip if same verdict already reviewed at current HEAD)
        id: idempotency
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
          COMMENT_ID: ${{ github.event.comment.id }}
        run: |
          HEAD_SHA=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json headRefOid --jq '.headRefOid')
          echo "head_sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"

          COMMENT_BODY=$(gh api "/repos/${REPO}/issues/comments/${COMMENT_ID}" --jq '.body')
          TARGET_VERDICT=$(echo "$COMMENT_BODY" | grep -oP '\*\*VERDICT:\s*\K(APPROVE|REQUEST_CHANGES)' | head -1 || true)
          if [ "$TARGET_VERDICT" = "APPROVE" ]; then
            TARGET_STATE="APPROVED"
          else
            TARGET_STATE="CHANGES_REQUESTED"
          fi
          echo "target_state=${TARGET_STATE}" >> "$GITHUB_OUTPUT"

          EXISTING=$(gh api "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" \
            --jq "[.[] | select(.user.login == \"github-actions[bot]\" and .commit_id == \"${HEAD_SHA}\" and .state == \"${TARGET_STATE}\")] | length")

          if [ "$EXISTING" -gt 0 ]; then
            echo "Already reviewed with ${TARGET_STATE} at head SHA ${HEAD_SHA}. Skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "No existing ${TARGET_STATE} review at ${HEAD_SHA}. Proceeding."
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Parse verdict and submit review
        if: steps.idempotency.outputs.skip != 'true'
        id: review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ github.event.comment.id }}
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
        run: |
          # Fetch the comment body via API to avoid direct shell exposure to user content
          COMMENT_BODY=$(gh api "/repos/${REPO}/issues/comments/${COMMENT_ID}" \
            --jq '.body')

          # Extract verdict — default to REQUEST_CHANGES if not parseable (fail-safe)
          VERDICT=$(echo "$COMMENT_BODY" | grep -oP '\*\*VERDICT:\s*\K(APPROVE|REQUEST_CHANGES)' | head -1 || echo "")
          if [ "$VERDICT" != "APPROVE" ] && [ "$VERDICT" != "REQUEST_CHANGES" ]; then
            echo "::warning::Could not parse verdict from comment, defaulting to REQUEST_CHANGES"
            VERDICT="REQUEST_CHANGES"
          fi
          echo "verdict=${VERDICT}" >> "$GITHUB_OUTPUT"
          echo "Parsed verdict: ${VERDICT}"

          # Extract summary (first non-empty line after "### Summary")
          SUMMARY=$(echo "$COMMENT_BODY" | awk '/^### Summary/{found=1; next} found && /^[^[:space:]]/{print; exit} found && /^[[:space:]]*$/{next} found{print; exit}' | head -1 || echo "Review completed.")
          echo "summary=${SUMMARY}" >> "$GITHUB_OUTPUT"

          # Get PR title for [Pipeline] detection and linked issue extraction
          PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json title --jq '.title')
          echo "pr_title=${PR_TITLE}" >> "$GITHUB_OUTPUT"

          # Extract linked issue number from PR body via jq (zero shell exposure to body)
          ISSUE_NUMBER=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body \
            --jq '[.body | scan("(?i)(?:close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\s+#(\\d+)")] | first | .[]? // empty' \
            | head -1 || true)
          echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"

          # Build review body from the agent comment (strip the marker line)
          REVIEW_BODY=$(echo "$COMMENT_BODY" | grep -v '^\[PIPELINE-VERDICT\]' | sed '/./,$!d')
          if [ "$VERDICT" = "APPROVE" ]; then
            REVIEW_BODY="## Pipeline Review — Approved"$'\n\n'"${REVIEW_BODY}"$'\n\n'"---"$'\n'"*Submitted by Pipeline Review Submit (github-actions[bot]).*"
          else
            REVIEW_BODY="## Pipeline Review — Changes Requested"$'\n\n'"${REVIEW_BODY}"$'\n\n'"---"$'\n'"*Submitted by Pipeline Review Submit (github-actions[bot]).*"
          fi

          # Submit the formal review as github-actions[bot] (via GITHUB_TOKEN)
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" \
            -f event="${VERDICT}" \
            -f body="${REVIEW_BODY}"

          echo "Submitted ${VERDICT} review on PR #${PR_NUMBER}"

      - name: Set review status check
        if: always() && steps.idempotency.outputs.head_sha != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_SHA: ${{ steps.idempotency.outputs.head_sha }}
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
        run: |
          # The "review" status check is required by the branch protection ruleset.
          # Always set it — even if the review step was skipped by idempotency,
          # the status check may still be missing from a prior run.
          VERDICT="${{ steps.review.outputs.verdict }}"
          if [ -z "$VERDICT" ]; then
            # Review was skipped — check existing review to determine verdict
            VERDICT=$(gh api "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" \
              --jq '[.[] | select(.user.login == "github-actions[bot]")] | last | .state // ""' || echo "")
          fi
          if [ -z "$VERDICT" ]; then
            echo "No verdict available — skipping status check"
            exit 0
          fi
          gh api --method POST "/repos/${REPO}/statuses/${HEAD_SHA}" \
            -f state="success" \
            -f context="review" \
            -f description="Review completed: ${VERDICT}"
          echo "Set 'review' status check to success on ${HEAD_SHA} (verdict: ${VERDICT})"

      - name: Mark draft PR ready (APPROVE only)
        if: steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict == 'APPROVE'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
        run: |
          PR_DRAFT=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json isDraft -q '.isDraft')
          if [ "$PR_DRAFT" = "true" ]; then
            gh pr ready "$PR_NUMBER" --repo "$REPO" || echo "::warning::Could not mark PR as ready"
          else
            echo "PR #${PR_NUMBER} is already ready for review."
          fi

      - name: Enable auto-merge (APPROVE only)
        if: steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict == 'APPROVE' && steps.healing.outputs.enabled == 'true'
        env:
          MERGE_TOKEN: ${{ secrets.GH_AW_GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          PR_TITLE: ${{ steps.review.outputs.pr_title }}
          REPO: ${{ github.repository }}
        run: |
          if [[ "$PR_TITLE" == "[Pipeline]"* ]]; then
            if [ -z "$MERGE_TOKEN" ]; then
              echo "::error::GH_AW_GITHUB_TOKEN is required for pipeline auto-merge so downstream push workflows can run."
              exit 1
            fi
            GH_TOKEN="$MERGE_TOKEN" gh pr merge "$PR_NUMBER" --repo "$REPO" --auto --squash || echo "::warning::Could not enable auto-merge"
            echo "PR #${PR_NUMBER} approved and auto-merge enabled."
          else
            echo "PR #${PR_NUMBER} approved. Non-pipeline PR — skipping auto-merge."
          fi

      - name: Record auto-merge evidence (APPROVE only)
        if: steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict == 'APPROVE' && steps.healing.outputs.enabled == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_SHA: ${{ steps.idempotency.outputs.head_sha }}
          PR_NUMBER: ${{ github.event.issue.number }}
          PR_TITLE: ${{ steps.review.outputs.pr_title }}
          REPO: ${{ github.repository }}
        run: |
          if [[ "$PR_TITLE" != "[Pipeline]"* ]]; then
            echo "Non-pipeline PR — skipping auto-merge evidence status."
            exit 0
          fi
          if [ -z "$HEAD_SHA" ]; then
            echo "::warning::HEAD_SHA unavailable — cannot record auto-merge evidence."
            exit 0
          fi
          gh api --method POST "/repos/${REPO}/statuses/${HEAD_SHA}" \
            -f state="success" \
            -f context="auto-merge-armed" \
            -f description="Auto-merge enabled by PR Review Submit"
          echo "Recorded auto-merge evidence on ${HEAD_SHA}"

      - name: Close linked issues after merge (APPROVE only)
        if: steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict == 'APPROVE'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          ISSUE_NUMBER: ${{ steps.review.outputs.issue_number }}
          REPO: ${{ github.repository }}
        run: |
          # Poll for merge completion and close linked issues as a deterministic
          # backstop. The merge itself uses GH_AW_GITHUB_TOKEN so downstream
          # push/merge workflows can still fire normally.
          # Poll for merge completion (auto-merge typically completes within seconds).
          MERGED=false
          for i in $(seq 1 24); do
            sleep 5
            STATE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json state --jq '.state')
            if [ "$STATE" = "MERGED" ]; then
              MERGED=true
              break
            fi
            echo "PR #${PR_NUMBER} state: ${STATE} (attempt $i/24)"
          done

          if [ "$MERGED" = "true" ]; then
            echo "PR #${PR_NUMBER} merged. Closing linked issues."
            if [ -n "${ISSUE_NUMBER:-}" ]; then
              ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
              if [ "$ISSUE_STATE" = "OPEN" ]; then
                gh issue close "$ISSUE_NUMBER" --repo "$REPO" \
                  -c "Closed by merge of PR #${PR_NUMBER}." || \
                  echo "::warning::Could not close issue #${ISSUE_NUMBER}"
              else
                echo "Issue #${ISSUE_NUMBER} already ${ISSUE_STATE}"
              fi
            else
              echo "No linked issue found — skipping issue close"
            fi
          else
            echo "::warning::Merge not observed within 120s for PR #${PR_NUMBER}."
            if [ -n "${ISSUE_NUMBER:-}" ]; then
              ISSUE_STATE=$(gh issue view "$ISSUE_NUMBER" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
              if [ "$ISSUE_STATE" = "OPEN" ]; then
                gh issue comment "$ISSUE_NUMBER" --repo "$REPO" \
                  --body "Merge not observed within 120s for PR #${PR_NUMBER}. Issue closure deferred to watchdog." || true
              fi
            fi
          fi

      - name: Close superseded duplicate PRs
        if: steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict == 'APPROVE'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          ISSUE_NUMBER: ${{ steps.review.outputs.issue_number }}
          REPO: ${{ github.repository }}
        run: |
          if [ -z "${ISSUE_NUMBER:-}" ]; then
            echo "No linked issue — skipping superseded PR check"
            exit 0
          fi

          # Check if this PR actually merged
          STATE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json state --jq '.state')
          if [ "$STATE" != "MERGED" ]; then
            echo "PR #${PR_NUMBER} not merged — skipping superseded PR cleanup"
            exit 0
          fi

          # Find other open [Pipeline] PRs referencing the same issue
          DUPES=$(gh pr list --repo "$REPO" --state open \
            --json number,title,body \
            --jq "[.[] | select(
              .number != ${PR_NUMBER} and
              (.title | startswith(\"[Pipeline]\")) and
              (.body | test(\"(?i)(close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\\\s+#${ISSUE_NUMBER}\\\\b\"))
            )] | .[].number")

          if [ -z "$DUPES" ]; then
            echo "No superseded PRs found for issue #${ISSUE_NUMBER}"
            exit 0
          fi

          for DUP in $DUPES; do
            echo "Closing superseded PR #${DUP}"
            gh pr close "$DUP" --repo "$REPO" --delete-branch \
              -c "Superseded by PR #${PR_NUMBER} which merged and closed issue #${ISSUE_NUMBER}." || \
              echo "::warning::Could not close PR #${DUP}"
          done

      - name: Dispatch repo-assist for next cycle
        if: always() && steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict != '' && steps.healing.outputs.enabled == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REVIEW_VERDICT: ${{ steps.review.outputs.verdict }}
          REVIEW_SUMMARY: ${{ steps.review.outputs.summary }}
          PR_NUMBER: ${{ github.event.issue.number }}
          ISSUE_NUMBER: ${{ steps.review.outputs.issue_number }}
          REPO: ${{ github.repository }}
        run: |
          VERDICT="$REVIEW_VERDICT"
          SUMMARY="$REVIEW_SUMMARY"

          OPEN_ISSUES=$(gh issue list --repo "$REPO" \
            --label pipeline --label feature --state open --json number --jq 'length')
          OPEN_INFRA=$(gh issue list --repo "$REPO" \
            --label pipeline --label infra --state open --json number --jq 'length')
          OPEN_PRS=$(gh pr list --repo "$REPO" \
            --state open --json number,title --jq '[.[] | select(.title // "" | startswith("[Pipeline]"))] | length')
          TOTAL=$((OPEN_ISSUES + OPEN_INFRA + OPEN_PRS))

          if [ "$TOTAL" -eq 0 ]; then
            echo "No open pipeline issues or PRs remaining. Pipeline complete!"
            exit 0
          fi

          echo "Review verdict: $VERDICT. Found $TOTAL open pipeline items."

          if [ "$VERDICT" = "APPROVE" ]; then
            # APPROVE path: dispatch repo-assist in scheduled mode for next issue
            gh workflow run repo-assist.lock.yml --repo "$REPO" || \
              echo "::warning::Could not dispatch repo-assist"
          else
            # REQUEST_CHANGES path: post /repo-assist on the linked issue so the
            # agent enters Command Mode with specific fix instructions.
            TARGET_ISSUE="${ISSUE_NUMBER:-}"
            if [ -n "$TARGET_ISSUE" ]; then
              gh issue comment "$TARGET_ISSUE" --repo "$REPO" \
                --body "/repo-assist Fix review feedback on PR #${PR_NUMBER}. The reviewer said: ${SUMMARY}. Read the full review on PR #${PR_NUMBER}, implement all requested changes, push fixes to the PR branch, and comment what you changed." || \
                echo "::warning::Could not post /repo-assist comment"
            else
              echo "::warning::No linked issue found for PR #${PR_NUMBER} — cannot post /repo-assist"
            fi
          fi

  # ---------------------------------------------------------------------------
  # Job 2: workflow_dispatch trigger — break-glass manual path
  # ---------------------------------------------------------------------------
  submit-review-dispatch:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name == 'workflow_dispatch'

    concurrency:
      group: "pr-review-submit-${{ github.event.inputs.pr_number }}"
      cancel-in-progress: false

    env:
      PIPELINE_HEALING_ENABLED: ${{ vars.PIPELINE_HEALING_ENABLED }}

    steps:
      - name: Checkout workflow helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: scripts/healing-control.sh
          sparse-checkout-cone-mode: false

      - name: Check healing pause switch
        id: healing
        run: |
          if scripts/healing-control.sh is-enabled; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
            echo "Autonomous healing is paused via PIPELINE_HEALING_ENABLED."
          fi

      - name: Check idempotency (skip if same verdict already reviewed at current HEAD)
        id: idempotency
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          REPO: ${{ github.repository }}
          TARGET_VERDICT: ${{ github.event.inputs.verdict }}
        run: |
          HEAD_SHA=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json headRefOid --jq '.headRefOid')
          echo "head_sha=${HEAD_SHA}" >> "$GITHUB_OUTPUT"

          if [ "$TARGET_VERDICT" = "APPROVE" ]; then
            TARGET_STATE="APPROVED"
          else
            TARGET_STATE="CHANGES_REQUESTED"
          fi
          echo "target_state=${TARGET_STATE}" >> "$GITHUB_OUTPUT"

          EXISTING=$(gh api "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" \
            --jq "[.[] | select(.user.login == \"github-actions[bot]\" and .commit_id == \"${HEAD_SHA}\" and .state == \"${TARGET_STATE}\")] | length")

          if [ "$EXISTING" -gt 0 ]; then
            echo "Already reviewed with ${TARGET_STATE} at head SHA ${HEAD_SHA}. Skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
          else
            echo "No existing ${TARGET_STATE} review at ${HEAD_SHA}. Proceeding."
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Submit review from dispatch inputs
        if: steps.idempotency.outputs.skip != 'true'
        id: review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          VERDICT: ${{ github.event.inputs.verdict }}
          SUMMARY: ${{ github.event.inputs.summary }}
          REPO: ${{ github.repository }}
        run: |
          echo "verdict=${VERDICT}" >> "$GITHUB_OUTPUT"
          echo "Submitting break-glass ${VERDICT} review on PR #${PR_NUMBER}"

          # Get PR title for [Pipeline] detection and linked issue extraction
          PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json title --jq '.title')
          echo "pr_title=${PR_TITLE}" >> "$GITHUB_OUTPUT"

          # Extract linked issue number from PR body
          ISSUE_NUMBER=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body \
            --jq '[.body | scan("(?i)(?:close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\s+#(\\d+)")] | first | .[]? // empty' \
            | head -1 || true)
          echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"

          REVIEW_BODY="## Pipeline Review — Break-glass ${VERDICT}"$'\n\n'"${SUMMARY}"$'\n\n'"---"$'\n'"*Submitted via workflow_dispatch by @${{ github.actor }}.*"

          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" \
            -f event="${VERDICT}" \
            -f body="${REVIEW_BODY}"

          echo "Submitted ${VERDICT} review on PR #${PR_NUMBER}"

      - name: Set review status check
        if: always() && steps.idempotency.outputs.head_sha != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_SHA: ${{ steps.idempotency.outputs.head_sha }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          REPO: ${{ github.repository }}
        run: |
          VERDICT="${{ steps.review.outputs.verdict }}"
          if [ -z "$VERDICT" ]; then
            VERDICT=$(gh api "/repos/${REPO}/pulls/${PR_NUMBER}/reviews" \
              --jq '[.[] | select(.user.login == "github-actions[bot]")] | last | .state // ""' || echo "")
          fi
          if [ -z "$VERDICT" ]; then
            VERDICT="${{ github.event.inputs.verdict }}"
          fi
          if [ -z "$VERDICT" ]; then
            echo "No verdict available — skipping status check"
            exit 0
          fi
          gh api --method POST "/repos/${REPO}/statuses/${HEAD_SHA}" \
            -f state="success" \
            -f context="review" \
            -f description="Review completed: ${VERDICT}"
          echo "Set 'review' status check to success on ${HEAD_SHA} (verdict: ${VERDICT})"

      - name: Mark draft PR ready (APPROVE only)
        if: always() && github.event.inputs.verdict == 'APPROVE'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          REPO: ${{ github.repository }}
        run: |
          PR_DRAFT=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json isDraft -q '.isDraft')
          if [ "$PR_DRAFT" = "true" ]; then
            gh pr ready "$PR_NUMBER" --repo "$REPO" || echo "::warning::Could not mark PR as ready"
          else
            echo "PR #${PR_NUMBER} is already ready for review."
          fi

      - name: Enable auto-merge (APPROVE only)
        if: always() && github.event.inputs.verdict == 'APPROVE' && steps.healing.outputs.enabled == 'true'
        env:
          MERGE_TOKEN: ${{ secrets.GH_AW_GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          REPO: ${{ github.repository }}
        run: |
          PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json title --jq '.title')

          if [[ "$PR_TITLE" == "[Pipeline]"* ]]; then
            if [ -z "$MERGE_TOKEN" ]; then
              echo "::error::GH_AW_GITHUB_TOKEN is required for pipeline auto-merge so downstream push workflows can run."
              exit 1
            fi
            GH_TOKEN="$MERGE_TOKEN" gh pr merge "$PR_NUMBER" --repo "$REPO" --auto --squash || echo "::warning::Could not enable auto-merge"
            echo "PR #${PR_NUMBER} approved and auto-merge enabled."
          else
            echo "PR #${PR_NUMBER} approved. Non-pipeline PR — skipping auto-merge."
          fi

      - name: Record auto-merge evidence (APPROVE only)
        if: always() && github.event.inputs.verdict == 'APPROVE' && steps.healing.outputs.enabled == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_SHA: ${{ steps.idempotency.outputs.head_sha }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          PR_TITLE: ${{ steps.review.outputs.pr_title }}
          REPO: ${{ github.repository }}
        run: |
          if [[ "$PR_TITLE" != "[Pipeline]"* ]]; then
            echo "Non-pipeline PR — skipping auto-merge evidence status."
            exit 0
          fi
          if [ -z "$HEAD_SHA" ]; then
            echo "::warning::HEAD_SHA unavailable — cannot record auto-merge evidence."
            exit 0
          fi
          gh api --method POST "/repos/${REPO}/statuses/${HEAD_SHA}" \
            -f state="success" \
            -f context="auto-merge-armed" \
            -f description="Auto-merge enabled by PR Review Submit"
          echo "Recorded auto-merge evidence on ${HEAD_SHA}"

      - name: Close linked issues after merge (APPROVE only)
        if: always() && github.event.inputs.verdict == 'APPROVE'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          ISSUE_NUMBER: ${{ steps.review.outputs.issue_number }}
          REPO: ${{ github.repository }}
        run: |
          MERGED=false
          for i in $(seq 1 24); do
            sleep 5
            STATE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json state --jq '.state')
            if [ "$STATE" = "MERGED" ]; then
              MERGED=true
              break
            fi
            echo "PR #${PR_NUMBER} state: ${STATE} (attempt $i/24)"
          done

          if [ "$MERGED" = "true" ]; then
            echo "PR #${PR_NUMBER} merged. Closing linked issues."
            TARGET="${ISSUE_NUMBER:-}"
            if [ -z "$TARGET" ]; then
              TARGET=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body \
                --jq '[.body | scan("(?i)(?:close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\s+#(\\d+)")] | first | .[]? // empty' \
                | head -1 || true)
            fi
            if [ -n "$TARGET" ]; then
              ISSUE_STATE=$(gh issue view "$TARGET" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
              if [ "$ISSUE_STATE" = "OPEN" ]; then
                gh issue close "$TARGET" --repo "$REPO" \
                  -c "Closed by merge of PR #${PR_NUMBER}." || \
                  echo "::warning::Could not close issue #${TARGET}"
              else
                echo "Issue #${TARGET} already ${ISSUE_STATE}"
              fi
            else
              echo "No linked issue found — skipping issue close"
            fi
          else
            echo "::warning::Merge not observed within 120s for PR #${PR_NUMBER}."
            TARGET="${ISSUE_NUMBER:-}"
            if [ -z "$TARGET" ]; then
              TARGET=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body \
                --jq '[.body | scan("(?i)(?:close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\s+#(\\d+)")] | first | .[]? // empty' \
                | head -1 || true)
            fi
            if [ -n "$TARGET" ]; then
              ISSUE_STATE=$(gh issue view "$TARGET" --repo "$REPO" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
              if [ "$ISSUE_STATE" = "OPEN" ]; then
                gh issue comment "$TARGET" --repo "$REPO" \
                  --body "Merge not observed within 120s for PR #${PR_NUMBER}. Issue closure deferred to watchdog." || true
              fi
            fi
          fi

      - name: Close superseded duplicate PRs
        if: always() && github.event.inputs.verdict == 'APPROVE'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          ISSUE_NUMBER: ${{ steps.review.outputs.issue_number }}
          REPO: ${{ github.repository }}
        run: |
          TARGET="${ISSUE_NUMBER:-}"
          if [ -z "$TARGET" ]; then
            TARGET=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json body \
              --jq '[.body | scan("(?i)(?:close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\s+#(\\d+)")] | first | .[]? // empty' \
              | head -1 || true)
          fi
          if [ -z "$TARGET" ]; then
            echo "No linked issue — skipping superseded PR check"
            exit 0
          fi

          STATE=$(gh pr view "$PR_NUMBER" --repo "$REPO" --json state --jq '.state')
          if [ "$STATE" != "MERGED" ]; then
            echo "PR #${PR_NUMBER} not merged — skipping superseded PR cleanup"
            exit 0
          fi

          DUPES=$(gh pr list --repo "$REPO" --state open \
            --json number,title,body \
            --jq "[.[] | select(
              .number != ${PR_NUMBER} and
              (.title | startswith(\"[Pipeline]\")) and
              (.body | test(\"(?i)(close[ds]?|fix(?:e[ds])?|resolve[ds]?)\\\\s+#${TARGET}\\\\b\"))
            )] | .[].number")

          if [ -z "$DUPES" ]; then
            echo "No superseded PRs found for issue #${TARGET}"
            exit 0
          fi

          for DUP in $DUPES; do
            echo "Closing superseded PR #${DUP}"
            gh pr close "$DUP" --repo "$REPO" --delete-branch \
              -c "Superseded by PR #${PR_NUMBER} which merged and closed issue #${TARGET}." || \
              echo "::warning::Could not close PR #${DUP}"
          done

      - name: Dispatch repo-assist for next cycle
        if: always() && steps.healing.outputs.enabled == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REVIEW_VERDICT: ${{ steps.review.outputs.verdict }}
          INPUT_VERDICT: ${{ github.event.inputs.verdict }}
          REVIEW_SUMMARY: ${{ github.event.inputs.summary }}
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
          ISSUE_NUMBER: ${{ steps.review.outputs.issue_number }}
          REPO: ${{ github.repository }}
        run: |
          VERDICT="${REVIEW_VERDICT:-$INPUT_VERDICT}"
          SUMMARY="$REVIEW_SUMMARY"

          OPEN_ISSUES=$(gh issue list --repo "$REPO" \
            --label pipeline --label feature --state open --json number --jq 'length')
          OPEN_INFRA=$(gh issue list --repo "$REPO" \
            --label pipeline --label infra --state open --json number --jq 'length')
          OPEN_PRS=$(gh pr list --repo "$REPO" \
            --state open --json number,title --jq '[.[] | select(.title // "" | startswith("[Pipeline]"))] | length')
          TOTAL=$((OPEN_ISSUES + OPEN_INFRA + OPEN_PRS))

          if [ "$TOTAL" -eq 0 ]; then
            echo "No open pipeline issues or PRs remaining. Pipeline complete!"
            exit 0
          fi

          echo "Review verdict: $VERDICT. Found $TOTAL open pipeline items."

          if [ "$VERDICT" = "APPROVE" ]; then
            gh workflow run repo-assist.lock.yml --repo "$REPO" || \
              echo "::warning::Could not dispatch repo-assist"
          else
            TARGET_ISSUE="${ISSUE_NUMBER:-}"
            if [ -n "$TARGET_ISSUE" ]; then
              gh issue comment "$TARGET_ISSUE" --repo "$REPO" \
                --body "/repo-assist Fix review feedback on PR #${PR_NUMBER}. The reviewer said: ${SUMMARY}. Read the full review on PR #${PR_NUMBER}, implement all requested changes, push fixes to the PR branch, and comment what you changed." || \
                echo "::warning::Could not post /repo-assist comment"
            else
              echo "::warning::No linked issue found for PR #${PR_NUMBER} — cannot post /repo-assist"
            fi
          fi

      - name: Log paused autonomous follow-up skip
        if: always() && steps.healing.outputs.enabled != 'true'
        run: echo "Review completed, but autonomous follow-up is paused via PIPELINE_HEALING_ENABLED."

      - name: Log paused autonomous follow-up skip
        if: always() && steps.idempotency.outputs.skip != 'true' && steps.review.outputs.verdict != '' && steps.healing.outputs.enabled != 'true'
        run: echo "Review completed, but autonomous follow-up is paused via PIPELINE_HEALING_ENABLED."
