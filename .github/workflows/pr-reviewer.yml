#
# PR Reviewer — Automated review for [Pipeline] pull requests.
#
# This is a standard GitHub Actions workflow (not an agentic .md workflow)
# so that it always uses GITHUB_TOKEN (github-actions[bot] identity).
# This ensures a different identity from the GitHub App that creates PRs,
# avoiding GitHub's self-approval restriction.
#

name: "PR Reviewer"

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, closed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to review"
        required: true
        type: number

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

concurrency:
  group: "pr-reviewer-${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
  cancel-in-progress: true

jobs:
  # Close linked issues when a PR is merged (GITHUB_TOKEN can't trigger Closes #N auto-close)
  close-issues:
    runs-on: ubuntu-latest
    if: |
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    steps:
      - name: Close linked issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_BODY="${{ github.event.pull_request.body }}"

          # Extract all "Closes #N" references
          ISSUES=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' || true)

          if [ -z "$ISSUES" ]; then
            echo "No 'Closes #N' found in PR body. Nothing to close."
            exit 0
          fi

          for ISSUE_NUM in $ISSUES; do
            STATE=$(gh issue view "$ISSUE_NUM" --repo "${{ github.repository }}" --json state --jq '.state' 2>/dev/null || echo "UNKNOWN")
            if [ "$STATE" = "OPEN" ]; then
              gh issue close "$ISSUE_NUM" --repo "${{ github.repository }}" \
                -c "Closed by merge of PR #${PR_NUMBER}." || \
                echo "::warning::Could not close issue #${ISSUE_NUM}"
              echo "Closed issue #${ISSUE_NUM}"
            else
              echo "Issue #${ISSUE_NUM} is already ${STATE}"
            fi
          done

  review:
    runs-on: ubuntu-latest
    # Review all PRs from this repo (skip forks for security, skip closed PRs)
    if: |
      github.event.action != 'closed' &&
      ((github.event_name == 'workflow_dispatch') ||
      (github.event.pull_request.head.repo.full_name == github.repository))

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR details
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          echo "number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"

          # Fetch PR metadata
          gh pr view "$PR_NUMBER" --json title,body,baseRefName,headRefName,additions,deletions,changedFiles \
            > pr_metadata.json

          PR_TITLE=$(jq -r '.title' pr_metadata.json)
          PR_BODY=$(jq -r '.body' pr_metadata.json)
          echo "title=${PR_TITLE}" >> "$GITHUB_OUTPUT"

          # Extract linked issue number from "Closes #N" pattern
          ISSUE_NUMBER=$(echo "$PR_BODY" | grep -oP 'Closes #\K[0-9]+' | head -1 || true)
          echo "issue_number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"

          # Fetch diff with smart truncation (GitHub Models API: 4000 token hard limit).
          # Strategy: always include test/data files in full, truncate implementation.
          # Budget: ~1200 instructions + ~800 criteria + ~2000 diff ≈ 4000 tokens.
          gh pr diff "$PR_NUMBER" > pr_diff_raw.txt
          TOTAL_LINES=$(wc -l < pr_diff_raw.txt)
          echo "Diff: $TOTAL_LINES lines"

          gh pr diff "$PR_NUMBER" --stat > pr_diff_summary.txt 2>/dev/null || true

          # Smart truncation: test/data files in full, implementation truncated.
          # Write Python script to temp file to avoid YAML indentation conflicts.
          cat > /tmp/smart_diff.py << 'PYEOF'
          import re, sys
          with open("pr_diff_raw.txt") as f:
              raw = f.read()
          with open("pr_diff_summary.txt") as f:
              stat = f.read().strip()
          chunks = re.split(r'(?=^diff --git )', raw, flags=re.MULTILINE)
          chunks = [c for c in chunks if c.strip()]
          test_chunks, data_chunks, impl_chunks = [], [], []
          for chunk in chunks:
              first_line = chunk.split('\n')[0] if chunk else ''
              path = first_line.split(' b/')[-1] if ' b/' in first_line else ''
              if any(k in path.lower() for k in ['test', 'spec', '__test']):
                  test_chunks.append(chunk)
              elif any(k in path.lower() for k in ['data/', 'fixture', 'failures.ts', 'simulator-content']):
                  data_chunks.append(chunk)
              else:
                  impl_chunks.append(chunk)
          MAX_LINES = 300
          out = ["### Changed files summary", stat, ""]
          for group in [test_chunks, data_chunks]:
              for chunk in group:
                  out.extend(chunk.rstrip().split('\n'))
          remaining = MAX_LINES - len(out)
          impl_text = '\n'.join(c.rstrip() for c in impl_chunks)
          impl_lines = impl_text.split('\n')
          if len(impl_lines) <= remaining:
              out.extend(impl_lines)
          else:
              out.extend(impl_lines[:remaining])
              out.append(f"[... impl truncated — {len(impl_lines)} lines, showed {remaining}. Tests+data in full above. ...]")
          print('\n'.join(out))
          PYEOF
          python3 /tmp/smart_diff.py > pr_diff.txt
          echo "Smart diff: $(wc -l < pr_diff.txt) lines (tests+data prioritized)"

      - name: Fetch linked issue
        id: issue
        if: steps.pr.outputs.issue_number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUMBER="${{ steps.pr.outputs.issue_number }}"
          gh issue view "$ISSUE_NUMBER" --json title,body > issue_metadata.json
          ISSUE_BODY=$(jq -r '.body' issue_metadata.json)
          echo "has_issue=true" >> "$GITHUB_OUTPUT"

          # Extract acceptance criteria section
          ACCEPTANCE_CRITERIA=$(echo "$ISSUE_BODY" | sed -n '/## Acceptance Criteria/,/^## /p' | head -n -1)
          if [ -z "$ACCEPTANCE_CRITERIA" ]; then
            ACCEPTANCE_CRITERIA="No acceptance criteria section found in the issue."
          fi

          # Write to file to avoid quoting issues
          echo "$ACCEPTANCE_CRITERIA" > acceptance_criteria.txt
          echo "$ISSUE_BODY" > issue_body.txt

      - name: Check CI status
        id: ci
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"

          # Get check runs status (exclude this workflow)
          CHECKS_JSON=$(gh pr checks "$PR_NUMBER" --json name,state,bucket 2>/dev/null || echo "[]")

          # Determine overall CI status
          FAILED_CHECKS=$(echo "$CHECKS_JSON" | jq -r '[.[] | select(.name != "PR Reviewer" and .bucket == "fail")] | length')
          PENDING_CHECKS=$(echo "$CHECKS_JSON" | jq -r '[.[] | select(.name != "PR Reviewer" and .bucket == "pending")] | length')

          if [ "$FAILED_CHECKS" -gt 0 ]; then
            echo "status=failing" >> "$GITHUB_OUTPUT"
            echo "summary=CI has $FAILED_CHECKS failing check(s)" >> "$GITHUB_OUTPUT"
          elif [ "$PENDING_CHECKS" -gt 0 ]; then
            echo "status=pending" >> "$GITHUB_OUTPUT"
            echo "summary=CI has $PENDING_CHECKS pending check(s)" >> "$GITHUB_OUTPUT"
          else
            echo "status=passing" >> "$GITHUB_OUTPUT"
            echo "summary=All CI checks pass" >> "$GITHUB_OUTPUT"
          fi

      - name: Read AGENTS.md
        id: agents
        run: |
          if [ -f AGENTS.md ]; then
            # Extract key sections for context
            head -200 AGENTS.md > agents_context.txt
          else
            echo "No AGENTS.md found." > agents_context.txt
          fi

      - name: Build review prompt
        id: prompt
        run: |
          cat > review_prompt.txt << 'PROMPT_HEADER'
          You are a senior code reviewer for an automated pipeline. Review this pull request and decide: APPROVE or REQUEST_CHANGES.

          ## Review Criteria

          1. **Acceptance Criteria**: Does the diff address ALL acceptance criteria from the linked issue? Each criterion must be met.
          2. **Correctness**: Are there obvious bugs, logic errors, or runtime failures?
          3. **Security**: Any injection vulnerabilities, exposed secrets, or unsafe operations?
          4. **Scope**: Does the PR stay within scope? Flag unrelated changes.
          5. **Code Quality**: Does the code follow the project's patterns (from AGENTS.md)?
          6. **Tests**: Are tests included where appropriate? Do they cover the acceptance criteria?

          ## Decision Rules

          - APPROVE if: all acceptance criteria are met, no obvious bugs or security issues, code is within scope
          - REQUEST_CHANGES if: any acceptance criteria are NOT met, there are bugs/security issues, or the PR is clearly out of scope
          - When CI is failing: always REQUEST_CHANGES with a note about CI failures
          - When CI is pending: you may still APPROVE if the code looks correct (CI will gate the merge)
          - Be pragmatic: minor style issues alone are NOT grounds for REQUEST_CHANGES

          ## Response Format

          You MUST respond with EXACTLY this format:

          DECISION: [APPROVE or REQUEST_CHANGES]

          SUMMARY: [1-2 sentence summary of your review]

          ISSUES:
          - [issue 1, if any]
          - [issue 2, if any]
          (or "None" if approving)

          PROMPT_HEADER

          echo "" >> review_prompt.txt
          echo "## PR: ${{ steps.pr.outputs.title }}" >> review_prompt.txt
          echo "" >> review_prompt.txt

          echo "## CI Status: ${{ steps.ci.outputs.summary }}" >> review_prompt.txt
          echo "" >> review_prompt.txt

          if [ -f acceptance_criteria.txt ]; then
            echo "## Linked Issue Acceptance Criteria" >> review_prompt.txt
            cat acceptance_criteria.txt >> review_prompt.txt
            echo "" >> review_prompt.txt
          fi

          # NOTE: Full issue body and AGENTS.md omitted — 4000 token API limit.
          # Acceptance criteria + full test/data diff is sufficient for review.

          echo "## Diff" >> review_prompt.txt
          echo '```diff' >> review_prompt.txt
          cat pr_diff.txt >> review_prompt.txt
          echo '```' >> review_prompt.txt

      - name: Run AI review
        id: review
        env:
          MODELS_TOKEN: ${{ secrets.MODELS_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Use GitHub Models REST API with a PAT that has models:read scope
          # Falls back to GITHUB_TOKEN if MODELS_TOKEN secret isn't set (will fail gracefully)
          # NOTE: Prompt is read from file by jq (not bash) to avoid shell expansion
          # corruption with large diffs containing special characters.
          REVIEW_OUTPUT=""
          for MODEL in openai/gpt-5 openai/gpt-5-mini openai/gpt-5-nano; do
            echo "Trying model: $MODEL"
            jq -n --arg model "$MODEL" --rawfile prompt review_prompt.txt '{
              model: $model,
              messages: [{role: "user", content: $prompt}]
            }' > /tmp/request.json
            HTTP_CODE=$(curl -s -o /tmp/response.json -w "%{http_code}" -X POST \
              "https://models.github.ai/inference/chat/completions" \
              -H "Authorization: Bearer $MODELS_TOKEN" \
              -H "Content-Type: application/json" \
              -d @/tmp/request.json)

            if [ "$HTTP_CODE" = "200" ]; then
              REVIEW_OUTPUT=$(jq -r '.choices[0].message.content // empty' /tmp/response.json)
              if [ -n "$REVIEW_OUTPUT" ]; then
                echo "Success with $MODEL (HTTP $HTTP_CODE)"
                break
              fi
            fi
            ERROR_MSG=$(cat /tmp/response.json 2>/dev/null | head -c 300)
            echo "::warning::$MODEL failed (HTTP $HTTP_CODE): $ERROR_MSG"
            REVIEW_OUTPUT=""
          done

          # Final fallback if all models fail
          if [ -z "$REVIEW_OUTPUT" ]; then
            echo "::warning::All AI models failed, falling back to basic review"
            if [ "${{ steps.ci.outputs.status }}" = "failing" ]; then
              REVIEW_OUTPUT="DECISION: REQUEST_CHANGES
          SUMMARY: CI checks are failing. Please fix CI failures before this PR can be approved.
          ISSUES:
          - CI is currently failing (${{ steps.ci.outputs.summary }})"
            else
              REVIEW_OUTPUT="DECISION: APPROVE
          SUMMARY: Automated review — CI checks are passing. AI review was unavailable.
          ISSUES:
          None"
            fi
          fi

          # Write to file for parsing
          echo "$REVIEW_OUTPUT" > review_output.txt
          cat review_output.txt

          # Parse decision
          DECISION=$(grep -oP '^DECISION:\s*\K\S+' review_output.txt | head -1 || echo "REQUEST_CHANGES")
          SUMMARY=$(grep -oP '^SUMMARY:\s*\K.*' review_output.txt | head -1 || echo "Review completed.")
          echo "decision=${DECISION}" >> "$GITHUB_OUTPUT"
          echo "summary=${SUMMARY}" >> "$GITHUB_OUTPUT"

      - name: Submit review — APPROVE
        if: steps.review.outputs.decision == 'APPROVE'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"

          # Build review body (use printf to preserve newlines; command substitution strips them)
          REVIEW_BODY="## Pipeline Review — Approved"
          REVIEW_BODY+=$'\n\n'"**Decision**: APPROVE"
          REVIEW_BODY+=$'\n\n'"$(cat review_output.txt | sed -n '/^SUMMARY:/,$ p')"
          REVIEW_BODY+=$'\n\n'"---"
          REVIEW_BODY+=$'\n'"*This review was performed by Pipeline Reviewer (github-actions[bot]).*"

          # Submit approval via GitHub API
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/pulls/${PR_NUMBER}/reviews" \
            -f event='APPROVE' \
            -f body="${REVIEW_BODY}"

          # If the PR is still a draft, mark it ready for review
          PR_DRAFT=$(gh pr view "$PR_NUMBER" --json isDraft -q '.isDraft')
          if [ "$PR_DRAFT" = "true" ]; then
            gh pr ready "$PR_NUMBER" || echo "::warning::Could not mark PR as ready"
          fi

          # Enable auto-merge only for [Pipeline] PRs (human PRs should be merged manually)
          PR_TITLE="${{ steps.pr.outputs.title }}"
          if [[ "$PR_TITLE" == "[Pipeline]"* ]]; then
            gh pr merge "$PR_NUMBER" --auto --squash || echo "::warning::Could not enable auto-merge"
            echo "PR #${PR_NUMBER} approved and auto-merge enabled."
          else
            echo "PR #${PR_NUMBER} approved. Non-pipeline PR — skipping auto-merge."
          fi

      - name: Dispatch repo-assist for next cycle
        if: always() && steps.review.outputs.decision != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          DECISION="${{ steps.review.outputs.decision }}"
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          ISSUE_NUMBER="${{ steps.pr.outputs.issue_number }}"
          SUMMARY="${{ steps.review.outputs.summary }}"

          OPEN_ISSUES=$(gh issue list --repo "${{ github.repository }}" \
            --label pipeline --label feature --state open --json number --jq 'length')
          OPEN_INFRA=$(gh issue list --repo "${{ github.repository }}" \
            --label pipeline --label infra --state open --json number --jq 'length')
          OPEN_PRS=$(gh pr list --repo "${{ github.repository }}" \
            --state open --json number,title --jq '[.[] | select(.title // "" | startswith("[Pipeline]"))] | length')
          TOTAL=$((OPEN_ISSUES + OPEN_INFRA + OPEN_PRS))

          if [ "$TOTAL" -eq 0 ]; then
            echo "No open pipeline issues or PRs remaining. Pipeline complete!"
            exit 0
          fi

          echo "Review decision: $DECISION. Found $TOTAL open pipeline items."

          if [ "$DECISION" = "APPROVE" ]; then
            # APPROVE path: use workflow_dispatch for general scheduled mode
            gh workflow run repo-assist.lock.yml --repo "${{ github.repository }}" || \
              echo "::warning::Could not dispatch repo-assist"
          else
            # REQUEST_CHANGES path: use /repo-assist slash command on the linked issue
            # so the agent enters Command Mode with specific fix instructions.
            # This prevents the agent from just posting a status update and exiting.
            TARGET_ISSUE="${ISSUE_NUMBER:-41}"
            gh issue comment "$TARGET_ISSUE" --repo "${{ github.repository }}" \
              --body "/repo-assist Fix review feedback on PR #${PR_NUMBER}. The reviewer said: ${SUMMARY}. Read the full review on PR #${PR_NUMBER}, implement all requested changes, push fixes to the PR branch, and comment what you changed." || \
              echo "::warning::Could not post /repo-assist comment"
          fi

      - name: Submit review — REQUEST_CHANGES
        if: steps.review.outputs.decision != 'APPROVE'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"

          # Build review body (use explicit newlines; command substitution strips trailing ones)
          REVIEW_BODY="## Pipeline Review — Changes Requested"
          REVIEW_BODY+=$'\n\n'"**Decision**: REQUEST_CHANGES"
          REVIEW_BODY+=$'\n\n'"$(cat review_output.txt | sed -n '/^SUMMARY:/,$ p')"
          REVIEW_BODY+=$'\n\n'"---"
          REVIEW_BODY+=$'\n'"*This review was performed by Pipeline Reviewer (github-actions[bot])."
          REVIEW_BODY+=$'\n'"repo-assist will automatically address this feedback on its next run.*"

          # Submit change request via GitHub API
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/pulls/${PR_NUMBER}/reviews" \
            -f event='REQUEST_CHANGES' \
            -f body="${REVIEW_BODY}"

          echo "PR #${PR_NUMBER} — changes requested."
